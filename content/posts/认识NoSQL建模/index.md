---
title: "认识NoSQL建模"
categories: ["NoSQL"]
tags: ["NoSQL","数据建模"]
date: "2023-07-22"
cover: "images/cover.png"
thumbnail: "images/cover.png"
draft: false
summary: "不会建模跟不会用数据库其实没什么区别。"
---

| 用语 <div style="width:8em"> | 解释 |
| ----------- | ----------- |
| 查询模式 | 特定于上下文的查询需求。 |


**数据建模**是指**为数据设计<u>内存结构和存储结构之间的映射关系</u>的过程**。而**数据模型**则是该过程的产物，它由一系列*结构定义*、*约束规则*及其*关系*组成。
[Martin Fowler](https://en.wikipedia.org/wiki/Martin_Fowler_(software_engineer))将*数据模型*定义为**认知和操作数据时所使用的模型，是一种数据库组织数据的方式**。

与SQL（泛指*关系型数据库*）不同。NoSQL 通常并不遵循[关系建模范式](https://en.wikipedia.org/wiki/Database_normalization)。甚至不同的 NoSQL 实现其*数据建模*方式也大有差别。**设计者需要根据 <u>NoSQL 所提供的具体特性</u>，以及<u>系统实际的查询模式</u>来进行建模决策**。

*关系模型*的优势在于查询的*灵活性*和*数据一致性*。对于遵循范式的*数据模型*而言，可以通过灵活的 SQL 来聚合数据（如*join*）。而且因为没有冗余，所以其数据一致性几乎能够满足所有严苛场景。然而，在面对大数据量存取需求时，该模型会显得相当乏力。或者说，*关系模型*本身就不是针对大数据场景而设计的。

在为*业务系统*进行 NoSQL 数据建模时，比较常用的方案是**面向聚合建模**。简单来说就是将相关信息放在一起。至于“相关”到底如何定义，则取决于具体系统的查询模式。这是因为 NoSQL（通常）不提供*ACID事务*承诺，在**多指令任务**上下文中无法确保最基本的*原子性*。或者说，NoSQL 对于*原子性*的支持非常有限。大部分仅支持**单指令/文档**级别的*原子性*，所以在进行*数据建模*时就需要将相关信息放在一起，以便满足*原子性*。
*面向聚合建模*可以透过两种方式来实现：**嵌入**和**引用**。
*嵌入*指的是将*关联（或部份的一部份）*直接嵌入到主体（文档）中。适用于 *数据规模较少*、*对读性能有要求*、*不可变* 等需要场景。例如在电商上下文中，可以直接将*订单项（列表）*嵌入到具体*订单*中。以此来确保*订单*在提交后，其*订单项（列表）*不会被改变。
而*引用*的概念其实和*关系模型*中的*外键*大致相同。即只将*关联*的*标识*嵌入到主体（文档）中。适用于 *数据量较大*、*对一致性有较高要求* 等场景。
然而，因为*聚合模型*没有完全遵循范式设计，所以通常情况下多多少少都会存在一些冗余数据（。特别是采用*嵌入*时）。这使得设计者需要额外引入**数据同步机制**来确保其一致性。

*聚合模型*相较于*关系模型*需要更加关注具体系统的查询模式。因为*关系模型*本身查询起来比较灵活，所以建模时可以脱离系统查询模式而仅需遵循范式来进行设计。但*聚合模型*就不能这样。它需要根据具体 NoSQL 提供的特性，以及实际的查询模式来进行建模。

## 参考
- 《NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence》Martin Fowler
