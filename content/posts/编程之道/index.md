---
title: "编程之道"
slug: "The Art of Programming"
categories: ["软件工程"]
tags: ["软件工程"]
date: "2025-06-20"
cover: "images/cover.png"
thumbnail: "images/cover.png"
summary: "关于我学了十年编程的一些看法，以及分享一下应该如何看待如今 AI 所带来的冲击。"
showTableOfContents: true
---

## 程序员的自我修养

### 写代码不是重点

和很多人一样，最开始我也是对一些编程工具抱有一些执念的。譬如找工作一定要是 Java、框架默认选用 Spring 和 ORM、数据库只用 MySQL 等等。这些在我现在看来其实都是些不太好的观念。随着对软件工程理解的加深，发现其实写代码这件事本身也只是一种相对比较次要的工作而已。一个非常简单的道理，就譬如当一个人理解错了需求，那么他接下来的所有行为可能都是没有意义的。而且社会分工经常会令人产生一种错觉，譬如一些人会认为“我只负责写代码，理解错需求不关我事”。但在我看来问题并非如此表面，因为真正落实需求的是开发人员，所以一旦需求产生变化就意味着需要修改代码甚至重写，而这种成本可能是巨大的。所以在这我想要表达的第一个观点就是**切勿轻视需求分析、理解和探索等相关工作，甚至应该花更多时间在这方面上**。一种有效的方法是透过反覆交谈和确认来减少理解偏差（。这种做法其实是敏捷开发协作建模的精髓）。我相信相较于做错事，“麻烦一点”的成本要低得多。

### 无架构

自参加工作以来我就职过几家公司，基本上开发的都是自研项目。自研项目有个特点就是生命周期很长，甚至可能与公司同生共死。而这一特点则为软件开发工作带来极大的挑战，因为长时间的迭代开发会令到那些不良的设计和操作的弊端全部浮现出来。若相关技术债务得不到妥善解决就会导致系统趋向一个无架构状态（俗称“大泥球/屎山代码”），从而变得极其难以维护。所以对于一个生命周期较长的系统来说，其实架构设计真的很重要。我个人将（软件）架构这一概念定义为<u>所有与实现细节无关的设计都属于架构</u>。这些工作包括但不限于 领域建模、数据建模、接口定义、代码组织结构、系统架构风格 等设计工作。然而在团队开发中架构设计最需要的其实是一种共识，一种大家都希望系统能够变得容易维护的共识。因为单方面的付出很难令到整件事情有所改变。但这也并非说毫无意义，其实**即便只在自己的工作区域中关注架构设计也能让相关工作变得容易一些**。这是我想要表达的第二个观点。其实在现实工作中真的很难指望能遇到一个好的团队或者项目，更多的情况是接手别人的烂摊子，所以掌握一些与遗留代码打交道的技巧也尤为重要。

### 过度设计

过度设计是导致系统变得难以维护的一个重要原因。因为该问题实在是太过普遍，真的有必要说一下。我曾经看过一本名为《[演进式架构](https://book.douban.com/subject/34793521/)》的书，里面提到一个有趣的概念叫做“面向简历编程”。一些人为了增加自己的履历会在公司项目中肆意地展示他们那些惊为天人的“设计能力”。这类人要么是缺乏经验，要么是缺乏责任心。因为他们根本意识不到（或毫不在意）在系统中应用与需求不匹配的设计会带来什么后果。这样会大大增加系统的维护成本，还会加重开发人员在知识和心理方面的负担。而且关键问题在于这些成本支出通常是毫无意义的。
所以我想传达的第三个观点是**除非有足够证据来证明确实有必要引入一些复杂设计或功能，否则就应该遵循 KISS（Keep It Simple, Stupid）和 YAGNI（You aren't gonna need it）两个原则直到最后责任时刻[^1]为止**。这样做不仅可以让系统架构持续地贴合实际需求来进行演进，而且还能有效地避免（或过早）引入毫无必要的复杂性。
我相信“用最少的成本将事情做好”这种价值观符合所有正常人的利益，但“面向简历编程”的人是例外。

过度设计的另类表现形式是过度抽象和过度复用，这同时也是 Java 开发备受争议的一点。
当开发人员对[面向对象编程（OOP）]({{% ref "/posts/面向对象编程再入门/index.md" %}})一知半解时就会滥用抽象和继承。个人强烈建议在编码时应该遵循 KISS 原则并在必要时再对代码进行重构，而不是一上来就进行抽象设计。因为在掌握更多细节信息之前，过度设计通常会与预期不符。作为一名合格的开发人员更应该掌握的是重构代码的能力，而不是习惯性地对未来的需求进行揣测，否则代码只会变得更难理解和维护。关于如何进行重构，可参考《[重构](https://book.douban.com/subject/30468597/)》一书。

另外有一件事需要注意，多年来我发现很多人对造轮子有种痴迷的心态。其实除非轮子本身会有专人来维护，否则应该避而远之；特别是那种覆盖面较广的轮子。因为一旦造轮子的人离开开发组，这些轮子就会变成一种负担。此时除了本职工作（负责解决项目本身的问题）之外，还要额外花时间和精力来维护轮子，但这种成本支出根本毫无必要。所以建议尽可能选用开源方案来解决问题，除非别无他法。

### 过早优化

除了上面提到的无架构和过度设计之外，还有一个容易导致系统变得难以维护隐形杀手是过早优化。据我长期观察，一些技术人员对国内某些所谓的“大厂”表现得十分虔诚，基本上“大厂”做什么他们就会跟做什么。而与这些“大厂”最相关的话题就莫过于性能优化，基本上动则都是成百上千万的 QPS[^2]。当技术人员对软件工程本身缺乏理解而又信奉了这些“大厂”后，其实就等同于落入了邪教。因为大部份过度设计都是在这种背景下产生的。而且它们所散发出来的价值观还会令人将关注点转移到一些对自己项目本身没有实际价值的地方上，这就是为什么总有人说“面试造火箭，上班拧螺丝”的原因。因为这些人根本就不知道自己在做什么。

根据经验，通常性能相对较好的方案都会与良好的代码结构设计相违背，这会导致代码的可读性和可维护性下降。
其中一个例子是过程式事务脚本和 OOP 领域模型。前者几乎没有什么额外的性能开销，但会随着复杂性提高而变得难以维护。后者高度结构化和语义清晰，所以可读性和可维护性都比较好，但会带来一些额外的性能开销（例如为了确保不变性而使用更多的内存）。然而最应该明白的一点是大多数业务型系统其实对性能根本不敏感，它们主要存在的问题是难以维护和扩展。我这么说并非在否定高性能代码所带来的价值，而是希望提醒一些人应该要学会权衡利弊。所以我想表达的第四个观点是**编码时应该优先考虑可读性和可维护性，然后待出现性能需求时再进行针对性优化**。其实当代码本身具备良好的可读性和可维护性后，性能优化工作的难度自然就会降低。但反过来则不然，因为此时的代码已经处于一个难以理解和修改的状态。对于那些需要维护长生命周期系统的人来说，明白这点真的很重要。

### 代码测试

《[修改代码的艺术](https://book.douban.com/subject/2248759/)》作者 Michael Feathers 曾在书中表示“对于我来说，遗留代码就是那些没有编写相应测试的代码”。相比之下，如今仍然有很多人对代码测试持有抵触心态。这些人普遍认为编写测试代码毫无作用，纯粹是浪费时间。而被提及最多的两个理由是<u>时间不允许</u>和<u>需求经常变化</u>。但根据个人经验，在没有测试代码的情况下就会花费更多时间在调试代码和手动测试上，而且这种时间通常还是不可控的。换句话说，这只不过是将原本应该用来编写测试代码的时间花在了调试代码和手动测试上。况且对于一个长生命周期项目来说有一套完善的测试套件非常重要。它不仅能够显著地提高代码质量和减少 BUG，而且还是保障代码重构和 CI/CD 活动必不可少的基础设施。因为当你无法确定代码修改会影响哪些地方时，这通常意味着需要重新对相关代码进行手动测试，这样非常低效。更糟糕的事是你可能会考虑拷贝一份代码来修改，而不是复用现有代码。这种行为会导致技术债务累积，让代码变成屎山。如果此时存在测试套件，那么自动化测试就可以对所有单元进行快速验证，从而给你足够的信心来确定这次修改没有破坏其他地方的代码行为。所以“时间不允许”这种理由其实根本就站不住脚，除非有人认为即便生产环境出了问题也与自己无关就另当别论。至于“需求经常变化”就更加无稽之谈。从编码角度来说，在一次开发任务期间需求通常不会有任何变化。这种状态至少会持续到下一次会议或任务下达之前。而且测试代码主要规范的是生产代码的接口，它相较于实现细节来说要稳定得多。除非在此之前相关人员根本没有花时间来设计和规范代码接口才可能会导致设计频繁发生变化。所以我要表达的第五个观点是**编写测试代码其实是一种长期投资，项目的生命周期越长它的回报就越大**。个人认为编写测试最有效的方式是 TDD（Test-Driven Development），它可以有效地避免编写出复杂的生产代码。因为代码越复杂就越难测试，而这个暗示将驱使你写出容易测试的代码。

### 开发工具

早些年在网上经常可以见到有人争论什么编程语言最好（如今其实也不少见）。作为一名学习了多年 Java 的人来说固然会对其产生一些偏爱。我想其中一个主要原因可能是因为见证着它一直在为适应新的软件环境而作出改变。譬如 Lambda、JPMS、Virtual Threads、Structured Concurrency、GraalVM AOT、JVM CRaC 等等。但即便如此，我也并不认为 Java 可以很好地胜任所有开发需求。其中一个活生生的例子是就是与 AI 领域相关的开发，显然 Python 和 JavaScript 这些动态语言被优先得到了更好的支持。此外，在并发编程需求场景中 FP 比 OOP 更加安全，此时可以考虑 F#、Scala 这类编程语言。

在进行技术选型时，若系统存在一些复杂度较高的功能需求，那么就应该选择一些抽象程度低的工具。因为抽象程度越高其灵活性就越低。而且抽象程度高的工具一般都会固执己见（限制编程方式），这会让代码甚至思维变得死板。譬如虽然 ORM 能够提升开发效率，但相较于 JDBC 其灵活性和扩展性就要差很多。当需要实现诸如权限控制或可观察性相关的操作时就会变得麻烦和别扭。而另一个比较典型的例子就是 Spring Boot。该框架的使用率非常高，但切勿忽视它因高抽象而带来的复杂性。当你正正常常使用它时可能会觉得很方便，然而一旦对其进行修改就需要事前具备大量的框架知识。一些古板的思维可能会认为这是理所当然的，但请不要忘记作为一名项目开发人员我们真正要解决的是项目本身的问题，而不是将大量时间和精力花费在工具上。所以我们应该尽可能避免这种情况发生，而其中一种解决方法就是选择低抽象的工具。低抽象的工具不仅灵活而且还易于使用。虽然会牺牲一些开发效率，但对于一个长生命周期项目来说绝对是利大于弊。譬如可以考虑用 Vert.x 或 Spring MVC 来代替自动配置的 Spring Boot。这是一个关于开发效率和掌控力的权衡。

一些过分追求交付速度或欠缺开发能力的公司会选择基于快速开发平台来进行项目开发（如：JHipster、JeecgBoot、RuoYi）。我曾经有幸参加过这类项目的维护和开发工作，只能用恶心两个字来形容。首先无可否认这些开发平台确实有其价值。譬如当需要快速开发一个一次性系统（只需要开发一次，以后无需负责维护），那么这些开发平台就理所当然成为首选，而且还非常适合可以自己接单的独立开发者。但恶心在于一些人用开发一次性系统的方式来开发一个需要长期迭代和维护的项目。这会导致系统充斥着各种无用代码和功能，从而对相关人员及其后续工作造成负担。当有新人加入团队时，他们不仅需要学习项目知识，还要额外花时间和精神研究这些开发平台。而且关键是这些开发平台本身也不见得设计得好。

因此我要表达的第六个观点是**应该优先考虑适合需求的工具，即便不是很熟悉**。其实但凡只要有过一两年编程经验后学习一门新工具并不是什么困难的事情。

### 对如今 AI 的看法

图灵奖得奖者 Fred Brooks 曾在《没有银弹[^3]》中表示软件项目的特性有点像人狼，一些看似普通的事情实则可能是一个难以估计的怪物。很多人试图寻找一种类似于银弹的东西来解决软件的复杂性。但 Fred Brooks 在（1985 年）当时认为，没有任何技术或管理手段能够承诺在生产率、可靠性或简洁性上可以取得数量级别的提升。随即 Fred Brooks 提出了一个对软件工程来说非常有价值的观点，就是将软件复杂性区分为根本复杂性和次要复杂性。大致上来说，根本复杂性源自于分析、探索和抽象出构成软件的概念模型的过程。而次要复杂性则源自将概念模型映射为机器语言的过程。他认为根本复杂性基本上无法简化，因为软件需求本身通常是模糊、抽象和复杂的，只有反复迭代才能慢慢趋向于完整和正确。而次要复杂性则可以运用科学的软件开发过程和技术手段来简化。

如今距离该篇论文的发布时间已经过去了 40 年，随着近年 AI 的火热，一些人开始讨论 AI 到底是不是软件开发的银弹。我个人认为这个话题非常有意义，因为如果 AI 确实能够解决软件项目的根本复杂性，那么程序员这个职业就意味着岌岌可危（至少大部份人将会失业）。在此前[一家名为 Y Combinator 的投资公司声称 AI 为旗下 25% 的创业公司编写了 95% 的代码](https://www.youtube.com/watch?v=IACHfKmZMr8)，但此番言论随即被很多专业开发人员斥责纯粹是炒作。因为在实际的编程工作中，真正用于编写代码的时间只是占少部分，而大部份是用于需求分析和代码调试。这让我想起了一件事，在 AI 刚火那会我在朋友圈半开玩笑说以后可能会有一个“描述式开发工程师”的新岗位，只是如今被叫做 Vibe coding[^4]。一些人表示 “AI 生成的代码并不具备可持续性”、“它不是魔法，你仍然需要辨识什么是好代码和坏代码”、“真正的工程师：2 小时编码，6 小时调试。Vibe 工程师：10 分钟编码，3 天调试”。而我个人最担心的问题是在工作上遇上一些缺乏软件质量意识的开发人员，他们可能会过度使用 Vibe coding。而这种行为本质上就等同于将一些连他们自己都不熟悉的代码提交到代码库中，甚至可能会因为错误地使用 AI 修改而影响其他的人工作。另外，除了 Vibe coding 外，其实 Autonomous coding 也是目前的一个探索方向。相较于前者（使用的代理，如：GitHub Copilot、Cline、Jetbrains Junie）Autonomous coding 更加先进，可以实现自主编写、测试、调试和部署代码等工作，而该过程期间仅需少量的人工操作。譬如 OpenAI Codex、Google Jules。有人建议可以尝试在一些非关键业务的简单任务上使用。

到目前为止，其实现今水平的 AI 主要还是用于减少软件的次要复杂性。而且在使用方面其不确定性和安全性仍然有待解决。这是我个人目前对 AI 的主要观点。因为先前在网上见有人提问“目前的 AI 能不能实现从无到有”，后来发现这确实是一个关键的问题。因为根本复杂性从本质上来说其实依赖于人类大脑的思维活动，譬如对问题的思考、理解、探索和创新。但这种能力已经属于 AGI（Artificial General Intelligence） 级别，然而 AGI 在现阶段也仅仅只是一种理想。但无论如何 AI 确实已经对各行各业产生了冲击。站在开发人员角度，个人认为必须改变以往以工具为主的编程学习方式。将关注点从工具使用转移到更加抽象的工作任务当中。也就是**将学习重点放在可以提高解决软件根本复杂性问题的能力上面。例如包括但不限于 业务分析和建模、架构设计、问题分析 等能力**。这是我最后想表达的价值观。

## 拓展：降低工具依赖性的简单方法

可以偶尔问下自己“如果项目要切换工具，大概需要多久”。时间越短就意味着功能实现和工具的耦合性越低。所以应该向着这个方向来设计代码。即便最终根本不需要切换工具，但做到这点代码也会变得灵活一些。

## 参考资料
- [工具定律](https://en.wikipedia.org/wiki/Law_of_the_instrument#Computer_programming)
- [代码整洁之道](https://book.douban.com/subject/34986245/)
- [KISS](https://zh.wikipedia.org/wiki/KISS%E5%8E%9F%E5%88%99)
- [YAGNI](https://zh.wikipedia.org/wiki/YAGNI)
- [Vibe coding](https://en.wikipedia.org/wiki/Vibe_coding)
- [Less is more](https://en.wikipedia.org/wiki/Less_is_more)
- [Transaction script is Antipattern?](https://stackoverflow.com/questions/16139941/transaction-script-is-antipattern)

[^1]: 最后责任时刻（Last Responsible Moment, LRM）是一个敏捷开发原则，指尽量避免过早作出决策，因为在缺乏足够信息之前作出的决策通常都是不明智的。在此之前应该收集更多信息和保留灵活性，直到不作出决策的成本超过作出决策的成本时才作出决策。
[^2]: QPS (Queries Per Second) = 请求数 / 时间窗口
[^3]: 没有银弹这篇论文后来被收录在《[人月神话](https://book.douban.com/subject/1102259/)》一书中。
[^4]: Vibe coding 的定义是“开发人员”无需学习和理解代码，而只需要以聊天的形式用 AI 创造软件（。这给很多业外人士带来一种错觉，认为软件开发是一件很容易的工作）。针对 Vibe coding，（Python）Django 作者 Simon Willison 表示如果每一行代码你都需要自己审查、测试并理解，那么就不属于 Vibe coding，这只不过是将 AI 作为打字机来使用而已。