---
title: "异常处理哲学"
slug: "Java Exception Handling Philosophy"
categories: ["Java"]
tags: ["Java", "异常处理"]
date: "2023-03-27"
cover: "images/cover.png"
thumbnail: "images/cover.png"
coverAlt: "cover"
thumbnailAlt: "cover"
summary: "不理解异常，又如何自定义异常？"
---

| 用语 <div style="width:8em"> | 解释 |
| ----------- | ----------- |
| 客户端 | 泛指使用 API 的地方。|
| 编程语义 | 代码程序所表达的真实意图。|
| 代码单元 | 泛指某种代码整体。如*代码块*、*方法*、*类*、*包*、*模块*等。|

在 Java 中，异常被分为两大类：**受检异常（checked exception）**、**未受检异常（unchecked exception）**。

**受检异常**包含`java.lang.Exception`、`java.lang.Throwable`两种类型。它们会受到**编译器**检测。当发现*客户端*没有及时处理异常时，其编译就会无法通过。
其设计目的是希望*客户端*能够及时地给出解决方案。
比较典型的例子是`java.io.IOException`。譬如当`java.io.FileInputStream#FileInputStream(java.io.File)`中的`file`不存在就会抛出`java.io.FileNotFoundException`。这里需要理解的是，为什么`FileNotFoundException`需要被及时处理。
这牵涉到代码设计层面的哲学，其背后的基础逻辑在于 API 设计者期望*客户端*能够及时并明确地给出异常的解决方案。这种逻辑思维通常建立在设计者的经验之上。
以`FileInputStream(java.io.File)`为例，它是一个**同步API**。换言之，它必须正确找到目标文件，否则就无法执行后续操作。出于这一原因，*客户端*就有必要给出一个明确的解决方案。譬如使用必然存在的默认文件来代替。当然，*客户端*此时也可能出现不知道何处理的情况。此时*客户端*可以选择接着往外层抛出异常，以便让更外层的*客户端*来处理它。但这种做法只应该在迫不得已的时候才进行，否则*受检异常*和*未受检异常*将变得无本质区别。
因此，可将*受检异常*的编程语义理解为**可预计且客户端有能力解决的问题**。

**未受检异常**包含`java.lang.Error`、`java.lang.RuntimeException`两种类型。典型例子是`java.lang.NullPointerException`和`java.lang.IllegalArgumentException`。通常两者类型都会涉及到外部输入。如*没有在数据库中找到对应的数据记录*、*用户提交的请求不符合规则*等。这些问题 API 通常是无法控制或解决的。或者说，出现这些问题时，就应该直接被系统用户所感知，而不是被暗地里解决；因为这样可能会引发歧义。
*编译器*并不会检测*未受检异常*，所以通常的应对方案是实施[防御性编程](https://zh.wikipedia.org/wiki/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B)。即在相应位置增加**校验逻辑**或**兜底操作**。较为常见的例子有*前置条件判定*、*AOP捕获*、*声明式处理（通常由SDK支持。在函数式/链式编程中被受青睐）*这些。可将*未受检异常*的编程语义理解为**无法预计或解决的问题**。因此，当遇到*无法预计*、*无法解决*、*不应由程序解决*等问题时，就可以运用未受检异常来将其建模。

在进行程序设计时，不应该将所有异常都交由**全局异常处理器**来解决，而是应该根据实际需求来选择*受检异常*或*未受检异常*后再进行针对处理。
一个较为典型的例子是`spring-tx`的声明式事务（`@Transactional`）。其默认只会回滚*未受检异常*。因为*受检异常*本身就该由*客户端*来处理，因为技术框架并不知道具体的异常处理需求。
此外，**过度依赖*全局异常处理器*会降低代码单元的内聚性**，因为部份逻辑被转移到了代码单元外。而低*内聚性*代码其维护成本往往较高（，特别是对于*非代码作者*而言）。所以一些编程语言甚至会强制要求异常需要进行就近处理（如*Golang*）。而且有时候异常处理可能会涉及部份业务逻辑，此时使用*全局异常处理器*将会破坏业务的完整性。
总的来说，*全局异常处理器*用不好会不利于可持续性设计。个人更推荐将其视为一种*兜底方案*，只在迫不得已时才使用它。切勿因为*全局异常处理器*可以*简化编程模型*和*节省些代码*就牺牲*内聚性*或*可读性*。
据经验而言，这些看起来“简单和便捷”的技术手段对于需要长期维护的代码而言通常是“致命”的。往往代码变得难以维护就是因为存在各种“简单和便捷”的念头。值得注意，“代码简洁”并不意味着拥有*可读性*和*可维护性*。要想拥有高可读和可维护的代码，必须遵循**高内聚，低耦合**的设计原则。