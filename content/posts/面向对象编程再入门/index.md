---
title: "面向对象编程再入门（Object-oriented programming，OOP）"
slug: Object oriented programming"
categories: ["Java"]
tags: ["Java", "面向对象"]
date: "2024-01-22"
cover: "images/cover.png"
thumbnail: "images/cover.png"
summary: "你知道面向对象风格的代码到底是怎样的吗？"
---

<b>内容修订</b>
- 2025/01/19：重构文章

| 用语 <div style="width:8em"> | 解释 |
| ----------- | ----------- |
| 不变性/固定规则 | 在特定程序生命周期内需要确保恒成立的条件。 |
| 对象 | 在哲学层面的解释是“被观察的事物”。而在 OOP 中，对象（Object）则是类（Class）的一个具体实例。|
| 行为 | 对象对外承担的职责。|
| 实体 | 在唯心主义哲学中可理解为“能被意识到的东西”。但在编程上下文中，实体通常是指具有唯一性的对象。|
| 概念模型 | 对问题空间进行高度抽象和形式化后的产物。这样做的目的是期望进一步理清问题空间本身的底层逻辑，以便更正确地解决问题。换句话说，对问题空间进行概念建模有利于更好地理解和传达信息。譬如在软件工程中存在着一个根本性问题（域）是<u>需要有一种高度抽象的工作来形式化现实问题</u>，而该问题通常的解决方案是基于（哲学）实体和各种示意图来达到抽象和形式化的目的。值得注意，在软件分析设计中，概念模型有时会被叫作业务模型或领域模型。它们本质上是同一个东西，与实现细节无关。|
| 反模式 | 在实践中经常出现，但违背良好设计原则的解决方案。注意，是否为反模式通常与上下文有关。| 
| 贫血（领域）模型 | 一种 OOP 的反模式。实体仅作为数据载体，而不具有业务性质的行为。因为违反了封装原则，所以严格上来说贫血模型并不是 OOP。 |
| 心智模型 | 指人类大脑里对事物运作方式的主观理解。|
| 虚方法 | 能被重写的实例方法。例如被 默认修饰符、public或protected 所修饰的方法。|
| 应用程序接口/API | 泛指程序与程序之间的连接点（。而非指代 Java 的 interface 特性）。|


## OOP 的底层逻辑

概念模型只能让相关人员更好地理解问题空间，它本身并不具备直接映射为编程语言的条件。因为抽象程度高，缺乏了大部份的细节信息。换言之，设计人员首先需要探索概念模型，并结合在该过程中形成的心智模型来对实体进行进一步设计。

所谓面向对象其实就是将问题视为一系列相互作用的对象集合，而这些对象会通过名称来执行对应的操作。在 OOP 中，会以类（Class）形式对实体进行进一步设计。类实际上是一个包含了实体所有细节信息（状态和行为）的程序单元。从程序角度而言，其实类就相当于是对实体的进一步抽象。因为真正具体化实体概念的是对象（Object）。而对象是类的具体实例，它代表一个可独立执行计算的实体。

### 三大特性回顾

类必须将实体的状态[^1]和行为捆绑在一起，然后对其（状态）进行访问控制。换言之，实体的状态只应该透过行为来改变，而不应该被直接访问或修改[^2]。该特性称为**封装**（或信息隐藏）。通过相较稳定的接口将不稳定内部状态与客户端隔离，以避免客户端有意或无意地绕过不变性从而破坏实体的内部状态。封装的含义是 OOP 最基本但同时又是最容易被忽视的。

有时实体会出现“同宗”关系。譬如一个人在公司中即是经理，又是员工。这种关系在 OOP 中可以通过**继承**来进行建模。但继承这种特性在业界经常被人诟病；因为当人无法正确理解和使用它时，会导致代码变得不可靠和难以维护。其实要想正确使用继承就必须从实体概念层面进行考量，并且仅在确实存在“同宗”关系时才应该使用它。另外值得一提，继承只是 OOP 下的一种建模方式，它不是必要的；更不应该为了代码复用而使用继承。该方面的更多知识可以参考[IS-A](https://en.wikipedia.org/wiki/Is-a)和[里氏替换原则（LSP）](https://en.wikipedia.org/wiki/Liskov_substitution_principle)。

**多态**本质上是一种允许程序在运行时才确定具体行为的机制。甚至可以这么说，OOP 之所以流行的一个重要原因就是多态。因为基于多态这一特性，开发人员可以很容易就编写出可测试和可灵活扩展的代码。这对于本身比较复杂且又需要长期迭代的系统来说很有帮助。从原理上来说，运行时多态是透过虚方法调用机制来实现的（该方式有时也被称为“动态分派”[^3]）。每个对象在内存中都有一个所属类的虚方法表引用。虚方法表记录了方法签名与具体方法体的关系，而这种关系只有在子类重写了父类方法时才会改变。所以当一个对象的虚方法并执行时，其实与引用该对象的变量类型没有任何关系。

## OOP 精粹：消息传递（Message passing）

OOP 提出者 Alan Kay 曾表示“**对我来说，OOP 只意味着：消息传递、局部状态的保存、保护和隐藏，以及对一切进行极端的延迟绑定**”。从这段话里头可以很得出一些关键信息。内存对象和封装可以解决“局部状态的保存、保护和隐藏”的问题，而运行时多态则实现了“延迟绑定”。但问题关键是“消息传递”到底指什么？维基百科给出的定义是“**消息传递是一种在计算机上调用行为的技术。调用程序通过发送消息并依赖于对象来选择和执行适当的代码**”。也就说，消息传递其实同样依赖于运行时多态（至少在 Java 中是这样）。

理解消息传递对于 OOP 非常重要。因为消息传递其实是一种面向抽象编程思维。调用程序只需负责与目标程序的 API 进行交互，而无需理会目标程序实际上是如何执行的。这种交互方式使两者实现了松耦合。

为了更有效地将这种编程思想落实到 OOP 中，社区还为此提出了 `Tell, Don't Ask` 原则（简称：TDA）。
即“告诉，而非询问”。遵循该编程原则除了可以降低目标程序与相关上下文之间的耦合性之外，还能有效地防止领域模型演变成贫血模型（。这种情况可解释为实体业务逻辑外泄。业务规则越离散，代码就越难维护）。
```
// OOP：Tell, Don't Ask ✅
var user = ...
var book = ...
user.borrowingBook(book) 
    // 👉 在方法内部调用
    if (checkRules()) book.borrow(this.userId)

// 非OOP：业务逻辑与实体分离，外泄在调用上下文中 🙅
var user = ...
var book = ...
var libraryCard = user.libraryCard()
if (checkRules(libraryCard)) {
    user.borrowingBook(book.bookId())
    book.borrow(user.userId())
}
```
更多关于 OOP 的设计思想可参考：[通用职责分配原则（GRASP）](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design))

## 参考资料
- [Dr. Alan Kay on the Meaning of “Object-Oriented Programming”](https://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en)
- [Message passing](https://en.m.wikipedia.org/wiki/Message_passing)
- [Getter Eradicator](https://martinfowler.com/bliki/GetterEradicator.html)
- [Virtual function](https://en.wikipedia.org/wiki/Virtual_function)
- [Information hiding](https://en.m.wikipedia.org/wiki/Information_hiding)
- 《面向对象分析和设计》第3版

[^1]: 对象的状态属性可以分为两种：数据属性通常会被直接持久化存储。计算属性则由数据属性和特定规则计算而来。拓展：在备忘录/快照模式[GoF]中，只需关注数据属性。
[^2]: 在 OOP 中，没有业务含义的 setter 方法其实是一种反模式。
[^3]: 除了动态分派外，还有静态分派。例如 Java 中的重载（Overload）。静态分派会根据编译时类型来确认调用目标。