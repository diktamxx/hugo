---
title: "面向对象编程再入门（Object-oriented programming，OOP）"
slug: Object oriented programming"
categories: ["Java"]
tags: ["Java", "面向对象"]
date: "2024-01-22"
cover: "images/cover.png"
thumbnail: "images/cover.png"
summary: "你知道面向对象风格的代码到底是怎样的吗？"
---

<b>内容修订</b>
- 2025/01/19：重构文章

| 用语 <div style="width:8em"> | 解释 |
| ----------- | ----------- |
| 不变性/固定规则 | 在特定程序生命周期内需要确保恒成立的条件。 |
| 对象 | 从哲学角度可将其理解为“被观察的事物”。而在 OOP 中，对象（Object）则是类（Class）的一个具体实例。|
| 行为 | 对象对外承担的职责。|
| 实体 | 从唯心主义哲学角度可将其理解为“能被意识到的对象”，这种对象本身可以客观存在或主观存在。在业务建模上下文中实体通常用来指代某种具有商业价值的概念。在编程上下文中则通常用来指代那些具有唯一性的对象。|
| 概念模型 | 对问题空间进行高度抽象和形式化后的产物。这样做的目的是期望进一步理清问题空间本身的底层逻辑，以便更正确地解决问题。换句话说，对问题空间进行概念建模有利于更好地理解和传达信息。譬如在软件工程中存在着一个根本性问题（域）是<u>需要有一种高度抽象的工作来形式化现实问题</u>，而该问题通常的解决方案是基于（哲学）实体和各种示意图来达到抽象和形式化的目的。值得注意，在软件分析设计中，概念模型有时会被叫作业务模型或领域模型。它们本质上是同一个东西，与实现细节无关。|
| 反模式 | 在实践中经常出现，但违背良好设计原则的解决方案。注意，是否为反模式通常与上下文有关。| 
| 贫血（领域）模型 | 一种 OOP 的反模式。实体仅作为数据载体，而不具有业务性质的行为。因为违反了封装原则，所以严格上来说贫血模型并不是 OOP，而是面向数据编程（DOP）。 |
| 心智模型 | 指人类大脑里对事物运作方式的主观理解。|
| 虚方法 | 能被重写的实例方法。例如被 默认修饰符、public 或 protected 所修饰的方法。|
| 应用程序接口/API | 泛指程序与程序之间的连接点（。而非指代 Java 的 interface 特性）。|
| 信息隐藏 | 将“相较稳定的部份”和“容易变化的部份”隔离，避免在变化时需要大面积改动设计或代码。要想做到这点就需要设计一个相较稳定的（公开）接口，该接口负责将那些无需被外界感知（或客户端根本不需要）的信息隐藏起来。注意，信息隐藏有时也称为受保护变体（Protected variations）。|


## 面向对象的底层逻辑

概念模型只能让相关人员更好地理解问题空间，它本身并不具备直接映射为编程语言的条件。因为抽象程度高，缺乏了大部份的细节信息。换言之，设计人员首先需要探索概念模型，并结合在该过程中形成的心智模型来对实体进行进一步设计。

面向对象分析（OOA）本质上是一种概念模型建模工具，其核心理念是将问题空间建模成一系列相互作用的对象集合（此处的对象准确来说其实是实体。实体通常同时具备属性和行为，可根据该特点来识别实体）。
面向对象设计（OOD）则是将概念模型转化为一个可行的实现方案。其工作需要站在领域业务和应用系统角度来对对象进行进一步探索，然后为其填充或设计原本因抽象而缺失的属性和行为。此外，OOD 应该着重关注对象的公开接口（即能被客户端感知的部份），因为该部份内容是信息隐藏的体现。
面向对象编程（OOP）则负责将 OOD 的产出映射为计算机可执行程序。OOP 会首先以类（Class）的形式来定义实体（它实际上是一个包含了特定实体所有细节信息的程序单元。或者可将其理解为“静态实体”），然后再以对象（Object）的形式来在内存中执行计算（此处的对象实际上是类的一个具体实例，可将其理解为“运行时实体”）。换句话说，在 OOP 中相当于：实体 ≈ 类 + 实例对象。值得注意，即便在 OOP 中也未必需要将所有内容都建模成一个完整的类。例如当建模目标只是一个简单的过程时，可以将其直接建模成一个函数（。虽然 Java 没有函数的概念[^1]，但可以通过静态方法来实现）。

### OOP 三大特性回顾

根据 OOP 定义，类必须将实体的状态[^2]和行为捆绑在一起，然后对其（状态）进行访问控制。
换言之，实体的状态只应该透过行为来改变，而不应该被直接访问或修改[^3]。该特性称为**封装**，是对象实现信息隐藏的主要方案。通过相较稳定的接口将不稳定内部状态与客户端隔离，以避免客户端有意或无意地绕过不变性从而破坏实体的内部状态。封装的含义是 OOP 最基本但同时又是最容易被忽视的。

有时实体会出现“同宗”关系。譬如一个人在公司中即是经理，又是员工。这种关系在 OOP 中可以通过**继承**来进行建模。但继承这种特性在业界经常被人诟病；因为当人无法正确理解和使用它时，会导致代码变得不可靠和难以维护。其实要想正确使用继承就必须从实体概念层面进行考量，并且仅在确实存在“同宗”关系时才应该使用它。另外值得一提，继承只是 OOP 下的一种建模方式，它不是必要的；更不应该为了代码复用而使用继承[^4]。该方面的更多知识可以参考[IS-A](https://en.wikipedia.org/wiki/Is-a)和[里氏替换原则（LSP）](https://en.wikipedia.org/wiki/Liskov_substitution_principle)。

**多态**本质上是一种允许程序在运行时才确定具体行为的机制。甚至可以这么说，OOP 之所以流行的一个重要原因就是多态。因为基于多态这一特性，开发人员可以很容易就编写出可测试和可灵活扩展的代码。这对于本身比较复杂且又需要长期迭代的系统来说很有帮助。在 Java 中运行时多态是透过虚方法调用机制来实现的（该方式有时也被称为“动态分派”[^5]）。每个对象在内存中都有一个所属类的虚方法表引用。虚方法表记录了方法签名与具体方法体的关系，而这种关系只有在子类重写了父类方法时才会改变。所以当一个对象的虚方法并执行时，其实与引用该对象的变量类型没有任何关系。

## OOP 精粹：消息传递（Message passing）

OOP 提出者 Alan Kay 曾表示“**对我来说，OOP 只意味着：消息传递、局部状态的保存、保护和隐藏，以及对一切进行极端的延迟绑定**”。从这段话里头可以很得出一些关键信息。内存对象和封装可以解决“局部状态的保存、保护和隐藏”的问题，而运行时多态则实现了“延迟绑定”。但问题关键是“消息传递”到底指什么？维基百科给出的定义是“**消息传递是一种在计算机上调用行为的技术。调用程序通过发送消息并依赖于对象来选择和执行适当的代码**”。也就是说消息传递其实同样依赖于运行时多态（在 Java 中是这样，而在 Python 中依赖的是[鸭子类型](https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B)）。

理解消息传递对于 OOP 非常重要。因为消息传递其实是一种面向抽象编程思维。调用程序只需负责与目标程序的 API 进行交互，而无需理会目标程序实际上是如何执行的。这种交互方式使两者实现了松耦合。

为了更有效地将这种编程思想落实到 OOP 中，社区还为此提出了 `Tell, Don't Ask` 原则（简称：TDA）。
即“告诉，而非询问”。遵循该编程原则除了可以降低目标程序与相关上下文之间的耦合性之外，还能有效地防止领域模型演变成贫血模型（。这种情况可解释为实体业务逻辑外泄。业务规则越离散，代码就越难维护）。
```
// OOP：Tell, Don't Ask ✅
var user = ...
var book = ...
user.borrowingBook(book) 
    // 👉 在方法内部调用
    if (checkRules()) book.borrow(this.userId)

// 非 OOP（贫血领域模型）：业务逻辑与实体分离，并散落在各个客户端中 🙅
var user = ...
var book = ...
var libraryCard = user.libraryCard()
if (checkRules(libraryCard)) {
    user.borrowingBook(book.bookId())
    book.borrow(user.userId())
}
```
更多相关的设计思想可参考：[通用职责分配原则（GRASP）](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design))、[SOLID](https://en.wikipedia.org/wiki/SOLID)


## 参考资料
- [Dr. Alan Kay on the Meaning of “Object-Oriented Programming”](https://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en)
- [Message passing](https://en.m.wikipedia.org/wiki/Message_passing)
- [Getter Eradicator](https://martinfowler.com/bliki/GetterEradicator.html)
- [Virtual function](https://en.wikipedia.org/wiki/Virtual_function)
- [Information hiding](https://en.m.wikipedia.org/wiki/Information_hiding)
- [Anemic domain model](https://en.wikipedia.org/wiki/Anemic_domain_model)
- 《面向对象分析和设计》第3版 Grady Booch
- 《Python3面向对象编程》第2版 Dusty Phillips

[^1]: 在 OOP 上下文中，方法指的是那些专门负责处理对象属性的函数。
[^2]: 对象的状态属性可以分为两种：数据属性通常会被直接持久化存储。计算属性则由数据属性和特定规则计算而来。拓展：在备忘录/快照模式[GoF]中，只需关注数据属性。
[^3]: 没有业务含义的 setter 方法其实是一种反模式。
[^4]: 正常情况下不应该通过继承来实现代码复用，但在 OOP 中有一种称为混合（Mixin）的设计模式是例外。混合的使用原则仅需满足 has-a 即可，它与普通类的区别在于前者只被视为一种代码片段。这种设计模式在支持多继承特性的编程语言中比较常见（如：Scala、Python），但在 Java 8 中也可以透过 interface 的 default 方法来实现（。因为 Java 本身支持多 interface 实现）。
[^5]: 除了动态分派外，还有静态分派。例如 Java 中的重载（Overload）。静态分派会根据编译时类型来确认调用目标。