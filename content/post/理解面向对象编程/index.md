---
title: "理解面向对象编程（Object-oriented programming）"
# description: ""
date: 2023-03-26
type: post
draft: false
tags: ["Java", "面向对象"]
categories: ["Java"]
---

#### 术语表
| 名称 | 描述 |
| ----------- | ----------- |
| **对象**： | 具有状态、行为和身份的实体。 |
| **概念模型**： | 用一组概念来描述一个系统，或用任何代替的形式来描述一个概念，以期能进一步了解或说明事物的运作原理。 |
| **不变性**： | 又叫“固定规则”。泛指一些在对象生命周期内保持不变的条件。 |
| **行为**： | 对象对外承担的职责。|
|  **贫血（领域）模型**： | 一种面向对象编程的反模式，其中领域对象包含很少或根本不包含业务逻辑，如验证、计算、规则等。因此，业务逻辑被嵌入到程序本身的架构中，使重构和维护更加困难且耗时。 |
| **反模式**：| 在实践中经常出现但又低效或是有待优化的设计模式。| 
| **编程模式**： | 编写代码的方式。 |



## 关于编程范式（编程风格）的定义
基于某种**概念模型**和**编程语言**来组织代码。目的是为了使代码能更清晰地表达这种**概念模型**。
例如使用**面向过程**、**面向对象**、**面向逻辑**等任意一种概念来描述系统。

## 什么是面向对象编程（OOP）？
程序被组织成许多组相互协作的对象，每个对象代表了某个类的一个实例，而类则属于一个通过继承关系而形成的层次结构[^1]。
[^1]: 《面向对象分析和设计》第3版

## 面向对象的3大特性
对象其实就是将**属性**和**方法（即函数）**捆绑在一起，然后对**属性**进行访问控制。这就是**封装**。目的是避免**不变性**遭受外界破坏。有个典型的Bug叫“aliasing bug[^2]”，可以了理解一下。
[^2]: http://www.catb.org/jargon/html/A/aliasing-bug.html

在**OOP**中**行为**才是重要的，而不是属性或者数据。因为**封装**特性的缘故，外界不能（亦不应该）直接访问对象的内部的属性，而只能是通过**行为**来改变对象的状态。因此，通常情况下应该根据**行为**来对**继承结构**进行**抽象**（想得到一个良好的继承结构，可参考“IS-A原则”和“里氏替换原则”）。关于多态的实现，可参考“[虚方法/虚函数](https://en.wikipedia.org/wiki/Virtual_function)”相关的资料。

**多态**是一种让代码可以运用**抽象结构**的能力（由运行时实现）。简单说，它是一种使得代码在运行期间可以根据**具体对象类型**来决定行为（准确点说是“方法体”）的代码执行机制。

## 一个非常重要的概念：面向对象引用传递

> 关于 Smalltalk :
>
> （面向对象）**消息传递**这一概念最早在Smalltalk编程语言中被实现，而Smalltalk的属性只能是私有的。也就说在Smalltalk中，外界仅能通过方法调用来实现对象之间的消息传递（从这一点来看，Java其实拥有更好的灵活性，但这使得它在面向对象方面并不那么纯粹）

### 1、定义
**消息传递**是一种在计算机上调用行为（运行程序）的技术，调用程序通过发送消息给一个进程（可能是对象或演员），依赖该进程及其支持基础设施来选择并运行适当的代码［维基百科］

### 2、理解
在**OOP**中，对象之间会透过**消息传递**来产生程序价值[^3]。例如**对象A**需要**对象B**的协助才来完成某项职责。那么上下文应该将**对象B**传递给**对象A**，然后再由**对象A**透过**消息传递**的形式来驱使**对象B**去履行相关部份的职责。而不是在上下文中直接访问**对象B**的内部属性然后再设置或传递给**对象A**。因为这样很容易导致对象变成**贫血领域模型**，从而丧失面向对象的优势。
[^3]: 程序价值：用户通过应用程序来解决现实问题

譬如当你试图绕过包含**不变性**逻辑的方法来直接访问对象属性时，就会导致一些不可预计的异常发生。简单说，在**OOP**中对象之间的交互仅应该透过**消息传递**这一抽象概念来实现。此外，**消息传递**本身还反映了对象的**封装性**和**抽象性**。因为**对象A**只需通过**消息传递**来要求**对象B**履行相关的职责，而并不需要关心**对象B**履行职责的细节过程，在此期间**对象B**的状态亦由它自己来负责维护。

**消息**指的是方法调用（，如果画过UML时序图可能会更好理解一些）。而**传递**则强调交互对象之间的**紧密性**。具体而言，它使得交互对象双方的**行为**被融合在了一起。譬如**消息传递**的过程应该在**对象A**方法中调用**对象B**方法，而不是在上下文中分别进行调用。此外，**消息**的类型大体可分为两种：**双向消息**和**单项消息**。区别在于后者的场景并不关心响应结果（在异步编程中常见）。此外，不直接称其为**方法调用**，是因为**消息传递**更能够凸显其过程的**抽象性**。这使得设计者能够更关注程序本身的行为，而不是行为之下的实现细节。

虽然**消息传递**在广义上是指对象之间的交互行为，但从代码设计层面来看，它实际上是一种编程模式。它强调对象在交互期间应该**相互接触**，通过**依赖目标对象及其行为**来实现目的，而非采取扁平化的过程式指令集来实现。

> 理解例子：在图书管理系统中，User用borrowingBook方法表示用户可以借书这一概念。而Book则有borrow方法表示自己可以被借出的概念。此时若根据**消息传递**编程模式来设计就会得到如下代码：
> ```
> // 消息传递 ✅
> var user = ...
> var book = ...
> user.borrowingBook(book) 
>   👉 方法内部调用 book.borrow(this.userId)
>
> // 扁平的过程式指令集 🙅
> var user = ...
> var book = ...
> user.borrowingBook(book.bookId())
> book.borrow(user.userId())
> ```

### 3、价值

1、能很好地模拟现实世界中个体之间的交互行为。这使得代码具有更好的表达能力。
\
2、促进封装和解耦。消息传递其实反映了职责的分离，正因对象有各自的职责才需要进行交互，这使得设计者对于职责的划分更加警惕。其次，消息传递主要包含参数和调用两部分。前者可依赖抽象进行建模，让交互对象双方实现松耦合。后者亦可以透过多态特性进一步对设计进行解耦。
\
3、为多态特性提供了实现所需的环境。因为消息传递本身只是一种交互抽象，这使得程序运行时可以透过虚方法的概念来实现方法的动态调用（根据对象的具体类型来决定）。

## 面向对象的价值
编程范式的价值在于能够更好的表达某种概念模型。从编程范式而言，理解**OOP**的**多态**其实是最重要的，因为用得好的话代码就可以很容易地做到松耦合。从建模层面而言，面向对象的价值则是有与之对应的技术工具[^4]。这使得你除了可以用面向对象概念来对现实业务领域进行分析设计之外，还可以继续使用**OOP**将**领域模型**进行编码落地。此外，面向对象概念模型可以较为容易地被人理解和接受，其 OOP 代码亦可以做到较高的灵活性[^5]。
[^4]: 面向对象概念模型已经得到广泛的编程语言支持
[^5]: 面向对象概念模型有前人丰富的知识沉淀。如有效的设计模式和设计原则

## 拓展
**函数式编程（FP）**和**OOP**两个并不冲突，可以结合使用。**FP**只是强调**引用透明性（如纯函数）**、**依赖运行时进行赋值操作**、**高阶函数**、**闭包**等特性。

## 参考
* https://en.m.wikipedia.org/wiki/Message_passing
* https://www.scaler.com/topics/oops-concepts-in-cpp
* https://news.ycombinator.com/item?id=19417893
* https://www.quora.com/What-is-the-significance-of-a-message-passing-in-OOP